/**
 * Copyright (c) 2022, Xerra Earth Observation Institute.
 * Copyright (c) 2025, Simeon Miteff.
 *
 * See LICENSE.TXT in the root directory of this source tree.
 */

// Code generated by go-tcpinfo/cmd/prom-metrics-gen. DO NOT EDIT.

package exporter

import (
	"fmt"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/simeonmiteff/go-tcpinfo/pkg/linux"
)

func (t *TCPInfoCollector) add_state_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_state", prefix),
			"Connection state, see include/net/tcp_states.h.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_state", prefix),
					"Connection state, see include/net/tcp_states.h.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.State),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_ca_state_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_ca_state", prefix),
			"Loss recovery state machine, see include/net/tcp.h.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_ca_state", prefix),
					"Loss recovery state machine, see include/net/tcp.h.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.CAState),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_retransmits_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_retransmits", prefix),
			"Number of timeouts (RTO based retransmissions) at this sequence (reset to zero on forward progress).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_retransmits", prefix),
					"Number of timeouts (RTO based retransmissions) at this sequence (reset to zero on forward progress).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Retransmits),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_probes_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_probes", prefix),
			"Consecutive zero window probes that have gone unanswered.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_probes", prefix),
					"Consecutive zero window probes that have gone unanswered.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Probes),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_backoff_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_backoff", prefix),
			"Exponential timeout backoff counter. Increment on RTO, reset on successful RTT measurements.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_backoff", prefix),
					"Exponential timeout backoff counter. Increment on RTO, reset on successful RTT measurements.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Backoff),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_options_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_options", prefix),
			"Bit encoded SYN options and other negotiations: TIMESTAMPS 0x1; SACK 0x2; WSCALE 0x4; ECN 0x8 - Was negotiated; ECN_SEEN - At least one ECT seen; SYN_DATA - SYN-ACK acknowledged data in SYN sent or rcvd.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_options", prefix),
					"Bit encoded SYN options and other negotiations: TIMESTAMPS 0x1; SACK 0x2; WSCALE 0x4; ECN 0x8 - Was negotiated; ECN_SEEN - At least one ECT seen; SYN_DATA - SYN-ACK acknowledged data in SYN sent or rcvd.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Options),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_snd_wscale_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_snd_wscale", prefix),
			"Window scaling of send-half of connection (bit shift).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_snd_wscale", prefix),
					"Window scaling of send-half of connection (bit shift).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SndWScale),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_wscale_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_wscale", prefix),
			"Window scaling of receive-half of connection (bit shift).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_wscale", prefix),
					"Window scaling of receive-half of connection (bit shift).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RcvWScale),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_delivery_rate_app_limited_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_delivery_rate_app_limited", prefix),
			"Flag indicating that rate measurements reflect non-network bottlenecks (1.0 = true, 0.0 = false).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.DeliveryRateAppLimited.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_delivery_rate_app_limited", prefix),
					"Flag indicating that rate measurements reflect non-network bottlenecks (1.0 = true, 0.0 = false).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				boolToFloat64(tcpInfo.DeliveryRateAppLimited.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_fastopen_client_fail_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_fastopen_client_fail", prefix),
			"The reason why TCP fastopen failed. 0x0: unspecified; 0x1: no cookie sent; 0x2: SYN-ACK did not ack SYN data; 0x3: SYN-ACK did not ack SYN data after timeout (-1.0 if unavailable).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.FastOpenClientFail.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_fastopen_client_fail", prefix),
					"The reason why TCP fastopen failed. 0x0: unspecified; 0x1: no cookie sent; 0x2: SYN-ACK did not ack SYN data; 0x3: SYN-ACK did not ack SYN data after timeout (-1.0 if unavailable).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.FastOpenClientFail.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rto_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rto", prefix),
			"Retransmission Timeout. Quantized to system jiffies.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rto", prefix),
					"Retransmission Timeout. Quantized to system jiffies.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RTO),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_ato_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_ato", prefix),
			"Delayed ACK Timeout. Quantized to system jiffies.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_ato", prefix),
					"Delayed ACK Timeout. Quantized to system jiffies.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.ATO),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_snd_mss_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_snd_mss", prefix),
			"Current Maximum Segment Size. Note that this can be smaller than the negotiated MSS for various reasons.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_snd_mss", prefix),
					"Current Maximum Segment Size. Note that this can be smaller than the negotiated MSS for various reasons.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SndMSS),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_mss_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_mss", prefix),
			"Maximum observed segment size from the remote host. Used to trigger delayed ACKs.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_mss", prefix),
					"Maximum observed segment size from the remote host. Used to trigger delayed ACKs.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RcvMSS),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_unacked_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_unacked", prefix),
			"Number of segments between snd.nxt and snd.una. Accounting for the Pipe algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_unacked", prefix),
					"Number of segments between snd.nxt and snd.una. Accounting for the Pipe algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.UnAcked),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_sacked_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_sacked", prefix),
			"Scoreboard segment marked SACKED by sack blocks. Accounting for the Pipe algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_sacked", prefix),
					"Scoreboard segment marked SACKED by sack blocks. Accounting for the Pipe algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Sacked),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_lost_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_lost", prefix),
			"Scoreboard segments marked lost by loss detection heuristics. Accounting for the Pipe algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_lost", prefix),
					"Scoreboard segments marked lost by loss detection heuristics. Accounting for the Pipe algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Lost),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_retrans_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_retrans", prefix),
			"Scoreboard segments marked retransmitted. Accounting for the Pipe algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_retrans", prefix),
					"Scoreboard segments marked retransmitted. Accounting for the Pipe algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Retrans),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_fackets_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_fackets", prefix),
			"Some counter in Forward Acknowledgment (FACK) TCP congestion control. M-Lab says this is unused?.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_fackets", prefix),
					"Some counter in Forward Acknowledgment (FACK) TCP congestion control. M-Lab says this is unused?.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.Fackets),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_last_data_sent_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_last_data_sent", prefix),
			"Time since last data segment was sent. Quantized to jiffies.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_last_data_sent", prefix),
					"Time since last data segment was sent. Quantized to jiffies.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.LastDataSent),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_last_ack_sent_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_last_ack_sent", prefix),
			"Time since last ACK was sent. Not implemented!.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_last_ack_sent", prefix),
					"Time since last ACK was sent. Not implemented!.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.LastAckSent),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_last_data_recv_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_last_data_recv", prefix),
			"Time since last data segment was received. Quantized to jiffies.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_last_data_recv", prefix),
					"Time since last data segment was received. Quantized to jiffies.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.LastDataRecv),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_last_ack_recv_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_last_ack_recv", prefix),
			"Time since last ACK was received. Quantized to jiffies.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_last_ack_recv", prefix),
					"Time since last ACK was received. Quantized to jiffies.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.LastAckRecv),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_pmtu_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_pmtu", prefix),
			"Maximum IP Transmission Unit for this path.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_pmtu", prefix),
					"Maximum IP Transmission Unit for this path.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.PMTU),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_ssthresh_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_ssthresh", prefix),
			"Current Window Clamp. Receiver algorithm to avoid allocating excessive receive buffers.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_ssthresh", prefix),
					"Current Window Clamp. Receiver algorithm to avoid allocating excessive receive buffers.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RcvSSThresh),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rtt_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rtt", prefix),
			"Smoothed Round Trip Time (RTT). The Linux implementation differs from the standard.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rtt", prefix),
					"Smoothed Round Trip Time (RTT). The Linux implementation differs from the standard.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RTT),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rttvar_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rttvar", prefix),
			"RTT variance. The Linux implementation differs from the standard.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rttvar", prefix),
					"RTT variance. The Linux implementation differs from the standard.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RTTVar),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_snd_ssthresh_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_snd_ssthresh", prefix),
			"Slow Start Threshold. Value controlled by the selected congestion control algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_snd_ssthresh", prefix),
					"Slow Start Threshold. Value controlled by the selected congestion control algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SndSSThresh),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_snd_cwnd_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_snd_cwnd", prefix),
			"Congestion Window. Value controlled by the selected congestion control algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_snd_cwnd", prefix),
					"Congestion Window. Value controlled by the selected congestion control algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SndCWnd),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_advmss_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_advmss", prefix),
			"Advertised maximum segment size.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_advmss", prefix),
					"Advertised maximum segment size.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.AdvMSS),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_reordering_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_reordering", prefix),
			"Maximum observed reordering distance.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_reordering", prefix),
					"Maximum observed reordering distance.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Reordering),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_rtt_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_rtt", prefix),
			"Receiver Side RTT estimate.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_rtt", prefix),
					"Receiver Side RTT estimate.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RcvRTT),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_space_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_space", prefix),
			"Space reserved for the receive queue. Typically updated by receiver side auto-tuning.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_space", prefix),
					"Space reserved for the receive queue. Typically updated by receiver side auto-tuning.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RcvSpace),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_total_retrans_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_total_retrans", prefix),
			"Total number of segments containing retransmitted data.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_total_retrans", prefix),
					"Total number of segments containing retransmitted data.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.TotalRetrans),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_pacing_rate_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_pacing_rate", prefix),
			"Current Pacing Rate, nominally updated by congestion control.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.PacingRate.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_pacing_rate", prefix),
					"Current Pacing Rate, nominally updated by congestion control.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.PacingRate.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_max_pacing_rate_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_max_pacing_rate", prefix),
			"Settable pacing rate clamp. Set with setsockopt( ..SO_MAX_PACING_RATE.. ).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.MaxPacingRate.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_max_pacing_rate", prefix),
					"Settable pacing rate clamp. Set with setsockopt( ..SO_MAX_PACING_RATE.. ).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.MaxPacingRate.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_bytes_acked_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_bytes_acked", prefix),
			"The number of data bytes for which cumulative acknowledgments have been received | RFC4898 tcpEStatsAppHCThruOctetsAcked.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.BytesAcked.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_bytes_acked", prefix),
					"The number of data bytes for which cumulative acknowledgments have been received | RFC4898 tcpEStatsAppHCThruOctetsAcked.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.BytesAcked.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_bytes_received_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_bytes_received", prefix),
			"The number of data bytes for which cumulative acknowledgments have been sent | RFC4898 tcpEStatsAppHCThruOctetsReceived.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.BytesReceived.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_bytes_received", prefix),
					"The number of data bytes for which cumulative acknowledgments have been sent | RFC4898 tcpEStatsAppHCThruOctetsReceived.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.BytesReceived.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_segs_out_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_segs_out", prefix),
			"The number of segments transmitted. Includes data and pure ACKs | RFC4898 tcpEStatsPerfSegsOut.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.SegsOut.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_segs_out", prefix),
					"The number of segments transmitted. Includes data and pure ACKs | RFC4898 tcpEStatsPerfSegsOut.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SegsOut.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_segs_in_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_segs_in", prefix),
			"The number of segments received. Includes data and pure ACKs | RFC4898 tcpEStatsPerfSegsIn.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.SegsIn.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_segs_in", prefix),
					"The number of segments received. Includes data and pure ACKs | RFC4898 tcpEStatsPerfSegsIn.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SegsIn.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_notsent_bytes_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_notsent_bytes", prefix),
			"Number of bytes queued in the send buffer that have not been sent.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.NotsentBytes.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_notsent_bytes", prefix),
					"Number of bytes queued in the send buffer that have not been sent.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.NotsentBytes.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_min_rtt_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_min_rtt", prefix),
			"Minimum RTT. From an older, pre-BBR algorithm.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.MinRTT.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_min_rtt", prefix),
					"Minimum RTT. From an older, pre-BBR algorithm.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.MinRTT.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_data_segs_in_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_data_segs_in", prefix),
			"Input segments carrying data (len>0) | RFC4898 tcpEStatsDataSegsIn (actually tcpEStatsPerfDataSegsIn).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.DataSegsIn.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_data_segs_in", prefix),
					"Input segments carrying data (len>0) | RFC4898 tcpEStatsDataSegsIn (actually tcpEStatsPerfDataSegsIn).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.DataSegsIn.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_data_segs_out_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_data_segs_out", prefix),
			"Transmitted segments carrying data (len>0) | RFC4898 tcpEStatsDataSegsOut (actually tcpEStatsPerfDataSegsOut).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.DataSegsOut.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_data_segs_out", prefix),
					"Transmitted segments carrying data (len>0) | RFC4898 tcpEStatsDataSegsOut (actually tcpEStatsPerfDataSegsOut).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.DataSegsOut.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_delivery_rate_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_delivery_rate", prefix),
			"Observed Maximum Delivery Rate.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.DeliveryRate.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_delivery_rate", prefix),
					"Observed Maximum Delivery Rate.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.DeliveryRate.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_busy_time_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_busy_time", prefix),
			"Time in usecs with outstanding (unacknowledged) data. Time when snd.una not equal to snd.next.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.BusyTime.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_busy_time", prefix),
					"Time in usecs with outstanding (unacknowledged) data. Time when snd.una not equal to snd.next.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.BusyTime.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rwnd_limited_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rwnd_limited", prefix),
			"Time in usecs spent limited by/waiting for receiver window.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.RwndLimited.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rwnd_limited", prefix),
					"Time in usecs spent limited by/waiting for receiver window.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RwndLimited.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_sndbuf_limited_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_sndbuf_limited", prefix),
			"Time in usecs spent limited by/waiting for sender buffer space. This only includes the time when TCP transmissions are starved for data, but the application has been stopped because the buffer is full and can not be grown for some reason.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.SndbufLimited.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_sndbuf_limited", prefix),
					"Time in usecs spent limited by/waiting for sender buffer space. This only includes the time when TCP transmissions are starved for data, but the application has been stopped because the buffer is full and can not be grown for some reason.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SndbufLimited.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_delivered_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_delivered", prefix),
			"Data segments delivered to the receiver including retransmits. As reported by returning ACKs, used by ECN.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.Delivered.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_delivered", prefix),
					"Data segments delivered to the receiver including retransmits. As reported by returning ACKs, used by ECN.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Delivered.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_delivered_ce_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_delivered_ce", prefix),
			"ECE marked data segments delivered to the receiver including retransmits. As reported by returning ACKs, used by ECN.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.DeliveredCE.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_delivered_ce", prefix),
					"ECE marked data segments delivered to the receiver including retransmits. As reported by returning ACKs, used by ECN.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.DeliveredCE.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_bytes_sent_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_bytes_sent", prefix),
			"Payload bytes sent (excludes headers, includes retransmissions) | RFC4898 tcpEStatsPerfHCDataOctetsOut.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.BytesSent.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_bytes_sent", prefix),
					"Payload bytes sent (excludes headers, includes retransmissions) | RFC4898 tcpEStatsPerfHCDataOctetsOut.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.BytesSent.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_bytes_retrans_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_bytes_retrans", prefix),
			"Bytes retransmitted. May include headers and new data carried with a retransmission (for thin flows) | RFC4898 tcpEStatsPerfOctetsRetrans.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.BytesRetrans.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_bytes_retrans", prefix),
					"Bytes retransmitted. May include headers and new data carried with a retransmission (for thin flows) | RFC4898 tcpEStatsPerfOctetsRetrans.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.BytesRetrans.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_dsack_dups_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_dsack_dups", prefix),
			"Duplicate segments reported by DSACK | RFC4898 tcpEStatsStackDSACKDups.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.DSACKDups.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_dsack_dups", prefix),
					"Duplicate segments reported by DSACK | RFC4898 tcpEStatsStackDSACKDups.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.DSACKDups.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_reord_seen_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_reord_seen", prefix),
			"Received ACKs that were out of order. Estimates reordering on the return path.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.ReordSeen.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_reord_seen", prefix),
					"Received ACKs that were out of order. Estimates reordering on the return path.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.ReordSeen.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_ooopack_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_ooopack", prefix),
			"Out-of-order packets received.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.RcvOOOPack.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_ooopack", prefix),
					"Out-of-order packets received.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.RcvOOOPack.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_snd_wnd_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_snd_wnd", prefix),
			"Peers advertised receive window after scaling (bytes).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.SndWnd.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_snd_wnd", prefix),
					"Peers advertised receive window after scaling (bytes).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.SndWnd.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rcv_wnd_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rcv_wnd", prefix),
			"local advertised receive window after scaling (bytes).",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.RcvWnd.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rcv_wnd", prefix),
					"local advertised receive window after scaling (bytes).",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.RcvWnd.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_rehash_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_rehash", prefix),
			"PLB or timeout triggered rehash attempts.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.Rehash.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_rehash", prefix),
					"PLB or timeout triggered rehash attempts.",
					connectionLabels,
					constLabels,
				),
				prometheus.GaugeValue,
				float64(tcpInfo.Rehash.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_total_rto_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_total_rto", prefix),
			"Total number of RTO timeouts, including SYN/SYN-ACK and recurring timeouts.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.TotalRTO.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_total_rto", prefix),
					"Total number of RTO timeouts, including SYN/SYN-ACK and recurring timeouts.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.TotalRTO.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_total_rto_recoveries_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_total_rto_recoveries", prefix),
			"Total number of RTO recoveries, including any unfinished recovery.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.TotalRTORecoveries.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_total_rto_recoveries", prefix),
					"Total number of RTO recoveries, including any unfinished recovery.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.TotalRTORecoveries.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) add_total_rto_time_metric(prefix string, connectionLabels []string, constLabels prometheus.Labels) info {
	return info{
		description: prometheus.NewDesc(
			fmt.Sprintf("%s_total_rto_time", prefix),
			"Total time spent in RTO recoveries in milliseconds, including any unfinished recovery.",
			connectionLabels,
			constLabels,
		),
		supplier: func(tcpInfo *linux.TCPInfo, labelValues []string) prometheus.Metric {
			if !tcpInfo.TotalRTOTime.Valid {
				return nil
			}
			return prometheus.MustNewConstMetric(
				prometheus.NewDesc(
					fmt.Sprintf("%s_total_rto_time", prefix),
					"Total time spent in RTO recoveries in milliseconds, including any unfinished recovery.",
					connectionLabels,
					constLabels,
				),
				prometheus.CounterValue,
				float64(tcpInfo.TotalRTOTime.Value),
				labelValues...,
			)
		},
	}
}

func (t *TCPInfoCollector) addMetrics(
	prefix string,
	connectionLabels []string,
	constLabels prometheus.Labels,
) {
	infos := []info{
		t.add_state_metric(prefix, connectionLabels, constLabels),
		t.add_ca_state_metric(prefix, connectionLabels, constLabels),
		t.add_retransmits_metric(prefix, connectionLabels, constLabels),
		t.add_probes_metric(prefix, connectionLabels, constLabels),
		t.add_backoff_metric(prefix, connectionLabels, constLabels),
		t.add_options_metric(prefix, connectionLabels, constLabels),
		t.add_snd_wscale_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_wscale_metric(prefix, connectionLabels, constLabels),
		t.add_delivery_rate_app_limited_metric(prefix, connectionLabels, constLabels),
		t.add_fastopen_client_fail_metric(prefix, connectionLabels, constLabels),
		t.add_rto_metric(prefix, connectionLabels, constLabels),
		t.add_ato_metric(prefix, connectionLabels, constLabels),
		t.add_snd_mss_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_mss_metric(prefix, connectionLabels, constLabels),
		t.add_unacked_metric(prefix, connectionLabels, constLabels),
		t.add_sacked_metric(prefix, connectionLabels, constLabels),
		t.add_lost_metric(prefix, connectionLabels, constLabels),
		t.add_retrans_metric(prefix, connectionLabels, constLabels),
		t.add_fackets_metric(prefix, connectionLabels, constLabels),
		t.add_last_data_sent_metric(prefix, connectionLabels, constLabels),
		t.add_last_ack_sent_metric(prefix, connectionLabels, constLabels),
		t.add_last_data_recv_metric(prefix, connectionLabels, constLabels),
		t.add_last_ack_recv_metric(prefix, connectionLabels, constLabels),
		t.add_pmtu_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_ssthresh_metric(prefix, connectionLabels, constLabels),
		t.add_rtt_metric(prefix, connectionLabels, constLabels),
		t.add_rttvar_metric(prefix, connectionLabels, constLabels),
		t.add_snd_ssthresh_metric(prefix, connectionLabels, constLabels),
		t.add_snd_cwnd_metric(prefix, connectionLabels, constLabels),
		t.add_advmss_metric(prefix, connectionLabels, constLabels),
		t.add_reordering_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_rtt_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_space_metric(prefix, connectionLabels, constLabels),
		t.add_total_retrans_metric(prefix, connectionLabels, constLabels),
		t.add_pacing_rate_metric(prefix, connectionLabels, constLabels),
		t.add_max_pacing_rate_metric(prefix, connectionLabels, constLabels),
		t.add_bytes_acked_metric(prefix, connectionLabels, constLabels),
		t.add_bytes_received_metric(prefix, connectionLabels, constLabels),
		t.add_segs_out_metric(prefix, connectionLabels, constLabels),
		t.add_segs_in_metric(prefix, connectionLabels, constLabels),
		t.add_notsent_bytes_metric(prefix, connectionLabels, constLabels),
		t.add_min_rtt_metric(prefix, connectionLabels, constLabels),
		t.add_data_segs_in_metric(prefix, connectionLabels, constLabels),
		t.add_data_segs_out_metric(prefix, connectionLabels, constLabels),
		t.add_delivery_rate_metric(prefix, connectionLabels, constLabels),
		t.add_busy_time_metric(prefix, connectionLabels, constLabels),
		t.add_rwnd_limited_metric(prefix, connectionLabels, constLabels),
		t.add_sndbuf_limited_metric(prefix, connectionLabels, constLabels),
		t.add_delivered_metric(prefix, connectionLabels, constLabels),
		t.add_delivered_ce_metric(prefix, connectionLabels, constLabels),
		t.add_bytes_sent_metric(prefix, connectionLabels, constLabels),
		t.add_bytes_retrans_metric(prefix, connectionLabels, constLabels),
		t.add_dsack_dups_metric(prefix, connectionLabels, constLabels),
		t.add_reord_seen_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_ooopack_metric(prefix, connectionLabels, constLabels),
		t.add_snd_wnd_metric(prefix, connectionLabels, constLabels),
		t.add_rcv_wnd_metric(prefix, connectionLabels, constLabels),
		t.add_rehash_metric(prefix, connectionLabels, constLabels),
		t.add_total_rto_metric(prefix, connectionLabels, constLabels),
		t.add_total_rto_recoveries_metric(prefix, connectionLabels, constLabels),
		t.add_total_rto_time_metric(prefix, connectionLabels, constLabels),
	}

	// Filter out metrics that might not be supported by the kernel
	for _, i := range infos {
		if i.supplier != nil {
			t.infos = append(t.infos, i)
		}
	}
}

func boolToFloat64(b bool) float64 {
	if b {
		return 1
	}
	return 0
}
